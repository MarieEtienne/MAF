---
title: "ACP : donn√©es manquantes, imputation, imputation multiple"
author:
  - name: Marie-Pierre Etienne
    affiliation:
      - ENSAI - CREST
    email: marie-pierre.etienne@ensai.fr
date: "Last updated on `r format(Sys.time(), '%d %B, %Y')`"
institute: https://marieetienne.github.io/MAF/
execute:
  freeze: auto
  eval: true
  echo: true
editor:
  markdown:
    wrap: 72
  mode: source
css: mpe_pres_revealjs.css
format:
  revealjs:
    theme: [default, custom.scss]
    width: 1050
    margin: 0.05
    slide-number: true
    slide-level: 2
    show-slide-number: print
    menu:
      useTextContentForMissingTitles: false
    mathjax: true  # Active MathJax
    self-contained: true
---


# Introduction

## ACP sur donn√©es r√©elles : rarement compl√®tes

**Constat empirique**

- Les tableaux analys√©s par ACP sont souvent incomplets :

  - mesures manquantes,
  - variables co√ªteuses ou difficiles √† acqu√©rir,
  - protocoles h√©t√©rog√®nes.

**Exemples concrets**

- Environnement : stations √ó variables physico-chimiques
  ‚Üí capteurs d√©faillants, donn√©es non synchrones.

- √âcologie : esp√®ces √ó traits fonctionnels
  ‚Üí traits manquants pour certaines esp√®ces.

- Socio-√©conomie : individus √ó indicateurs
  ‚Üí non-r√©ponse partielle aux questionnaires.

**Objectif de l‚ÄôACP**

R√©sumer la structure de d√©pendance *globale* entre variables

‚Üí difficile si le tableau est incomplet.


## Le suivi d'ozone √† Rennes

112 mesures journali√®res de variables m√©t√©orologiques (vitesse du vent, temp√©rature, pr√©cipitations, etc.) ainsi que la concentration d‚Äôozone, relev√©es √† Rennes (France) durant l‚Äô√©t√© 2001.

11 variables continues et 2 variables cat√©gorielles comportant 2 ou 4 modalit√©s.


Cet exemple est issu du package R  ` missMDA`

```{r}
library(tidyverse)
library(FactoMineR)
library(missMDA)
library(mice)
data("ozone")
ozone |> summarise_all(~sum(is.na(.)))
```


## Attitude 1 : suppression des individus incomplets

**Approche na√Øve**
- Conserver uniquement les lignes sans valeurs manquantes.

**Cons√©quences**
- Forte r√©duction de la taille de l‚Äô√©chantillon.
- Perte d‚Äôinformation multivari√©e.
- Biais potentiel si les manquants ne sont pas MCAR.


Une ACP ¬´ propre ¬ª sur peu de donn√©es peut √™tre moins informative  qu‚Äôune ACP bien trait√©e sur des donn√©es incompl√®tes.

### Exemple Ozone

```{r}
ozone |> count()
ozone |> drop_na() |> count()
table(rowSums(is.na(ozone)))
```

C'est bien dommage !!!

## Attitude 2 : faire avec ce qu'on a

**vision sch√©matique**

$$\mathbf{X} =
\begin{pmatrix}
x_{11} & x_{12} & \bullet & x_{14} \\
x_{21} & \bullet & x_{23} & x_{24} \\
x_{31} & x_{32} & x_{33} & \bullet
\end{pmatrix}$$
$\bullet$ : valeur manquante


On peut calculer une matrice de corr√©lation √† partir des couples de donn√©es disponibles.

**Probl√®me**

- Les corr√©lations sont calcul√©es sur des sous-√©chantillons diff√©rents.
- La matrice de covariance peut devenir incoh√©rente.

**Cons√©quence**

- Axes principaux instables ou difficilement interpr√©tables.


## La question centrale

**Question statistique**

- Comment estimer un sous-espace principal pertinent √† partir d‚Äôun tableau incomplet $\mathbf{X}_{obs}$ ?

**Deux grandes familles de r√©ponses**

1. Compl√©ter les donn√©es (imputation)

2. Mod√©liser directement la structure latente (ACP comme mod√®le factoriel)

üëâ Les deux approches sont √©troitement li√©es.


# Formalisation

## Donn√©es manquantes et ACP : cadre formel

**Donn√©es et notations**

- $\mathbf{X} \in \mathbb{R}^{n \times p}$ : matrice de donn√©es (souvent centr√©e, √©ventuellement r√©duite).
- $\mathbf{R} \in {0,1}^{n \times p}$ : indicateurs de donn√©es manquantes : $$r_{ij} = \begin{cases}
  1 & \text{si } x_{ij} \text{ est observ√©} \\
  0 & \text{si } x_{ij} \text{ est manquant}
  \end{cases}$$

- D√©composition : $\mathbf{X} = (\mathbf{X}*{obs},* \mathbf{X}{mis})$.

**ACP compl√®te**
$$\hat{\Sigma} = \frac{1}{n}\mathbf{X}^\top \mathbf{X}$$


**M√©canismes des donn√©es manquantes**

- **MCAR** : $P(\mathbf{R}\mid \mathbf{X}) = P(\mathbf{R})$
- **MAR** : $P(\mathbf{R}\mid \mathbf{X}) = P(\mathbf{R}\mid \mathbf{X}*{obs})$
- **MNAR** : $P(*\mathbf{R}\mid \mathbf{X})$ d√©pend de $\mathbf{X}{mis}$

**Impact sur l‚ÄôACP**
- $\hat{\Sigma}$ n‚Äôest plus directement calculable ; estimations ad hoc $\Rightarrow$ biais possibles.
- Distorsion des inerties et des sous-espaces principaux.

# Imputation de donn√©es

## Imputation simple : principe et propri√©t√©s

**Principe**

- Construire $\tilde{\mathbf{X}}$ par remplacement **ponctuel** des valeurs manquantes. - Appliquer ensuite une ACP standard sur $\tilde{\mathbf{X}}$.

**Quel remplacement ponctuel ?**

- **Moyenne** (si centr√©e : $0$) : $\tilde{x}_{ij} = \bar{x}_j$

- **R√©gression** :
On ajuste un mod√®le sur les donn√©es disponibles

$$x_{ij} = \beta_{0}^j +* \sum_{k\neq j}\beta_{k}^j x_{ik} + \varepsilon_{i}^j$$
et on pr√©dit

$$\hat{x}^{miss}_{ij} = \beta_{0}^j +* \sum_{k\neq j}\beta_{k}^j x_{ik}$$


- **ACP it√©rative / EM-PCA (id√©e)** : alternance (estimation sous-espace) / (reconstruction) jusqu‚Äô√† convergence. (Hors programme n√©cessite les cours de stat plus avanc√©s)

**Probl√®mes**
- Incertitude sur $\mathbf{X}_{mis}$ ignor√©e  $\Rightarrow$ variances souvent sous-estim√©es, corr√©lations modifi√©es.


## Imputation multiple et ACP

**Principe**
- G√©n√©rer (M) compl√©tions :
$$\tilde{\mathbf{X}}^{(1)}, \ldots, \tilde{\mathbf{X}}^{(M)}$$
en simulant $\mathbf{X}*{mis}$ selon une loi approchant $p(\mathbf{X}{mis}\mid \mathbf{X}_{obs})$ (souvent sous MAR + mod√®le).

**Analyse**
- ACP sur chaque $\tilde{\mathbf{X}}^{(m)}$ $\Rightarrow$ (M) jeux (valeurs propres, charges, scores).

**Combinaison (une option simple)**

$$\bar{\Sigma}=\frac{1}{M}\sum_{m=1}^M \hat{\Sigma}^{(m)} $$ puis ACP de $\bar{\Sigma}.$

+ diagnostics : variabilit√© inter-imputations des charges/axes.


## Pratiquement

**1) Diagnostiquer les manquants** - Taux global + par variable/individu ; structure (blocs, monotone, etc.). - Tester/argumenter (au moins qualitativement) MCAR vs MAR vs MNAR.

**2) Pr√©-traitement coh√©rent**
- D√©cider centrage / r√©duction (important en ACP sur corr√©lation).
- Id√©alement : inclure ce pr√©-traitement *dans* le mod√®le d‚Äôimputation (ou le reproduire √† l‚Äôidentique apr√®s imputation).

**3) Choisir la strat√©gie**
- **Exploration rapide** : imputation simple (moyenne / kNN / ACP it√©rative).
- **Inf√©rence / reporting** : imputation multiple (MI), surtout sous MAR.

**4) Estimer l‚ÄôACP**
- Sur (\tilde{\mathbf{X}}) (simple) ou sur chaque (\tilde{\mathbf{X}}^{(m)}) (IM).
- Attention √† l'alignement des axes si besoin (ind√©termination du signe / rotations).

**5) Diagnostics & sensibilit√©**
- Stabilit√© des charges/axes (bootstrap ou IM).
- Sensibilit√© au nombre de composantes (q), au mod√®le d‚Äôimputation, et (si plausible) sc√©narios MNAR.


## Deux mots sur l'ACP comme mod√®le factoriel (vue probabiliste)

**Mod√®le**
- Pour l‚Äôindividu (i) : $$\mathbf{x}_i = \boldsymbol{\mu} + \mathbf{L}\mathbf{z}_i + \boldsymbol{\varepsilon}_i$$
o√π
- $\mathbf{z}_i \in \mathbb{R}^q$ : facteurs latents (scores), - $\mathbf{L} \in \mathbb{R}^{p\times q}$ : charges (loadings),
- $\boldsymbol{\varepsilon}_i \sim \mathcal{N}(\mathbf{0}, \sigma^2\mathbf{I}_p)$ (hypoth√®se ‚Äúbruit isotrope‚Äù).

**Lien avec l‚ÄôACP**
- Si $\mathbf{z}_i \sim \mathcal{N}(0,\mathbf{I}_q)$, alors : $$\mathrm{Cov}(\mathbf{x}_i)=\mathbf{L}\mathbf{L}\top+\sigma2\mathbf{I}_p$$
- L‚Äôestimation des param√®tres (par maximum de vraisemblance ou EM, cf cours statistique inf√©rentielle) m√®ne √† un sous-espace proche de celui de l‚ÄôACP (cas $\sigma^2 I$ : ‚Äúprobabilistic PCA‚Äù).

**Pourquoi utile avec des manquants ?** - Le cadre probabiliste donne naturellement $p(\mathbf{X}^{mis}\mid \mathbf{X}{obs})$.
- EM : E-step (esp√©rances conditionnelles des facteurs et/ou manquants),
M-step (mise √† jour de $\mathbf{L},\sigma^2)$.

## Exemple de mise en ≈ìuvre (R) : ACP it√©rative vs imputation multiple

```{r}
#| eval: false
library(missMDA)
library(FactoMineR)
library(palmerpenguins)
library(mice)

data(penguins)
# Exemple : jeu de donn√©es continu avec manquants

X <- scale(penguins[, 3:6])
dim(X)
X_no_na <- X  |> as.data.frame() |> drop_na()
dim(X_no_na)
# ici juste pour l'exemple set.seed(1)
prop_na <- 0.15
Xmiss <- X
Xmiss[sample(x= length(Xmiss), size = round(0.15*length(Xmiss)))] <- NA
X_no_na <- Xmiss  |> as.data.frame() |> drop_na()
dim(X_no_na)

# --- (A) Imputation ACP it√©rative (missMDA) ---

# Choisir nb de composantes pour l'imputation (validation crois√©e)

ncp <- estim_ncpPCA(Xmiss, ncp.max = 5)$ncp ##¬†on teste la reconstruction par validation crois√©e
Xmiss_pca <- imputePCA(Xmiss, ncp = ncp)$completeObs
res_pca <- PCA(Xmiss_pca, graph = FALSE)

# --- (B) Imputation multiple (mice) ---

X_miss_df <- as.data.frame(Xmiss)

# M√©thode par d√©faut (pmm) souvent robuste ; adapter selon contexte
Xmiss_im  <- mice(X_miss_df,
                  m = 20,
                  method = "pmm", seed = 1, printFlag = FALSE) # methode pmm regression multiple a√† expliquer

# ACP sur chaque jeu imput√©
pcas <- lapply(1:Xmiss_im$m,
               function(m){
                 dta_m <- complete(Xmiss_im, m)
                 PCA(dta_m, graph = FALSE) })

# Combinaison simple : moyenne des matrices de covariance
Sigmas <- lapply(1:Xmiss_im$m,
                 function(m){
                   dta_m <- as.matrix(complete(Xmiss_im, m))
                   cov(dta_m)  # si d√©j√† centr√©/r√©duit : attention aux conventions
})
Sigma_bar <- Reduce("+", Sigmas) / Xmiss_im$m

# ACP sur Sigma_bar : via eigen-decomposition

# Base de r√©f√©rence : plan (PC1, PC2) de Sigma_bar
eig_bar <- eigen(Sigma_bar)
U <- eig_bar$vectors[, 1:2, drop = FALSE]  # p x 2 (orthonorm√©)

# Fonction : angles principaux (en degr√©s) entre deux plans 2D
principal_angles_2d <- function(U, V) {
  # cosinus des angles = valeurs singuli√®res de t(U) %*% V
  sv <- svd(t(U) %*% V, nu = 0, nv = 0)$d
  sv <- pmin(1, pmax(0, sv))  # s√©curit√© num√©rique
  acos(sv) * 180 / pi         # angles en degr√©s
}

# Angles entre le plan de Sigma_bar et le plan de chaque imputation
angles_deg <- sapply(seq_along(Sigmas), function(m) {
  eig_m <- eigen(Sigmas[[m]])
  V <- eig_m$vectors[, 1:2, drop = FALSE]
  principal_angles_2d(U, V)   # renvoie 2 angles : theta1 <= theta2
})

rownames(angles_deg) <- c("theta1_deg", "theta2_deg")
colnames(angles_deg) <- paste0("imp", seq_along(Sigmas))

# R√©sum√© utile
t(apply(angles_deg, 1, summary))
# ou visualiser rapidement
angles_deg[, 1:5]

```

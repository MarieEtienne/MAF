---
title: "Eléments de correction pour le TD1"
author: "Groupes de TD du 15/11"
format:
  html:
    code-fold: true
---



```{r setup}
knitr::opts_chunk$set(echo = TRUE, comment = NA, 
                      cache = TRUE, message = FALSE,
                      warning = FALSE, eval = TRUE,
                      fig.align = "center")
```


# Présentation de Quarto

Quarto permet de faire des rapports intégrant du code R, des sorties exécutées à partir de ce code et du texte présentant les analyses.

Ce document est rédigé avec quarto, le fichier source est disponible sur [ce lien](https://raw.githubusercontent.com/MarieEtienne/MAF/refs/heads/master/tp1_example.qmd)

# Présentation du contexte

Les données portent sur des échantillons de sols en différents sites, à différentes profondeurs en forêt de Bornéo. Diférentes variables de composition sont renseignées pour chaque échantillon, ainsi que le type de sol et la profondeur (par classe de profondeur).

On souhaite  visualiser les relations entre les variables et identifier une typologie des sols.

## Description des données

### Chargement des packages

```{r}
#| label: package 
#| code-fold: true
#| message: false

library(tidyverse)
library(FactoMineR)
```

Pour ajouter un chunk R CTL + Alt + i

### Importation des données

```{r}
#| label: charger_les_donnees 

dta <- read.table(file = "https://marieetienne.github.io/datasets/donnees_sols.txt", sep = ";", header = TRUE)
```

### Description des données

```{r}
#| label: desc
#| eval: true

# str(dta)
dta <- dta %>% mutate(Sol = as.factor(Sol),
               Site = as.factor(Site),
               Profondeur = factor(Profondeur), levels(c('Superficiel', 'Intermediaire', 'Profond'))) %>% 
  mutate(Profondeur = relevel(Profondeur, ref= "Superficiel"))
 summary(dta)
nobs <- nrow(dta)
p <- ncol(dta)
any(is.na(dta))
summary(dta$Profondeur)
```

Le fichier de données a `r nobs` lignes et `r p`colonnes.

il n'y a pas de données manquantes

```{r}
#| label: boxplot
dta %>% 
  ggplot() + 
  aes(x= Profondeur, y = Argile) + 
  geom_boxplot() +
  xlab('Classe de Profondeur')

boxplot(dta$Argile~ dta$Profondeur)
```

La somme des variables Limon, Argile et Sable devrait sommer à 100, mais ce n'est pas le cas à cause des erreurs d'arrondi

```{r}
#| label: argile

dta %>% 
  mutate(Total = Limon + Argile + Sable)  %>% 
  select(Total)
```

On peut s'interesser aux corrélations entre les variables

```{r}
#| label: correlation
#| echo: false
#| include: false
library("corrplot")
dta_quanti <- dta |> 
  select(where(is.numeric))
cor.mat <- round(cor(dta_quanti),2)
corrplot(cor.mat, type="upper", order="hclust", 
         tl.col="black", tl.srt=45)
```


### Représentation

## Identifier une typologie de sol

Pour visualiser les données on peut commencer par une ACP

-   sur les variables quantitatives uniquement

```{r}
#| label: Xmatrice

X <- dta %>% 
  select(where(is.numeric)) %>% as.matrix()
dim(X)
```

### Poids des individus

On va prendre les mêmes poids pour tous les individus soit $1/n$.

Les poids sont stockés dans la matrice $W$

### Distance à utiliser entre les individus

On commence par une distance euclidienne. La matrice de distance $M$ est l'identité

Le cours dit

-   l'inertie vaut $tr(X^\top W X M)$

-   On va chercher les valeurs et vecteurs propres de la matrice $X^\top W X M$

Si on fait une ACP non normée le sable et SatBase contribuent beaucoup plus à la formation des axes que les autres variables.

```{r}
#| label: approche_facto_brute
dta_pca <- PCA(X = dta, scale.unit = FALSE, quali.sup = c(1,2,3), ncp = 18)
#library(Factoshiny)
```

Pour rééquilibrer le poids des variables dans la construction des projections, on propose une ACP normée.

Pour voir comment l'information d'une variable se disperse sur les différentes dimensions on peut regarder la contribution de cette variable à la construction des différents axes.

Par exemple pour le PH

```{r}
round(dta_pca$var$contrib[1,],2)
```

On peut mettre en place une ACP normée en précisant simple `scale.unit = TRUE `, ce qui est le comportement par défaut de la fonction `PC̀A ̀. 

```{r}
#| label: approche_facto
dta_pca <- PCA(X = dta, scale.unit = TRUE, quali.sup = c(1,2,3), ncp = 18)
#library(Factoshiny)
```

Qualité globale des représentations

-   sur le plan 1-2 : on représente `r sum(dta_pca$eig[1:2, 2])`

-   sur le plan 1-3 : on représente `r sum(dta_pca$eig[c(1,3), 2])`

Avec 3 axes on représente `r sum(dta_pca$eig[c(1:3), 2])` de l'inertie.

On peut visualiser le cercle des corrélations

```{r}
#| label: visu_var
plot.PCA(dta_pca,choix='var',
         select='cos2  0.7',
         unselect=0)
```

A l'aide des contributions des différentes variables à la définition des axes, on peut comprendre l'information résumée par ces axes.



```{r}
dta_pca$var$contrib |> as.data.frame() |> arrange(-Dim.1) |> select(Dim.1)
dta_pca$var$contrib |> as.data.frame() |> arrange(-Dim.2)|> select(Dim.2)
dta_pca$var$contrib |> as.data.frame() |> arrange(-Dim.4) |> select(Dim.4)
```

La description des axes \* l'axe 1 parle de l'eau, des cations, du sable et de l'argile (et du limon) \* l'axe 2 du phosphate et du carbone \* petite remarque sur l'axe 4 qui est essentiellemnt NH4

```{r}
dta_pca$var$contrib |> as.data.frame() |> arrange(-Dim.1)
dta_pca$var$contrib |> as.data.frame() |> arrange(-Dim.2) |> select(Dim.2)
```

# Visualiser la profondeur sur les différents plans

# visualiser les types de sol

```{r}
#| label: type_sol

plot.PCA(dta_pca, axes=c(1,4),invisible=c('quali','ind.sup'),habillage=1,label ='none')

plot.PCA(dta_pca,choix='var',
         select='cos2  0.7', ## pour représenter seulement les variables dont le cos2 > 0.7
         unselect=0, axes = c(1,4) )
```


 il fallait chercher l'axe 4 pour bien illustrer les différences entre grès et dunaire, l'axe 4 est presque exclusivement l'information sur le NH4.


